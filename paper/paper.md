---
title: "macroframe-forecast: Smooth and Constraint-Consistent Forecasting"
tags:
- Python
- time series
- forecasting
- macroeconomics
- reconciliation
- smoothing
date: "28 August 2025"
output:
  pdf_document:
    keep_tex: true
    latex_engine: xelatex
  word_document: default
  html_document:
    df_print: paged
bibliography: paper.bib
citeproc: true
authors:
- name: Sakai Ando
  orcid: 0000-0003-2785-4375
  affiliation: '1'
- name: Shuvam Das
  orcid: 0009-0002-3406-4128
  affiliation: '1'
- name: Sultan Orazbayev
  orcid: 0000-0003-4097-4830
  affiliation: '1'
affiliations:
- name: International Monetary Fund
  index: 1
---

# Summary

The Python package `macroframe-forecast` generates forecasts that are both temporally smooth and consistent with user-specified constraints. The framework consists of model estimation and reconciliation: first, unconstrained forecasts are produced using user-specified statistical or machine learning models; second, these forecasts are adjusted to satisfy linear equality and inequality constraints while minimizing volatility over time in the forecast horizon. The package offers a user-friendly interface for specifying constraints as strings and supports advanced customization of weights and smoothing parameters.  An example - forecasting U.S. GDP with a terminal GDP growth rate target - illustrates the usage.

# Statement of need

In forecasting economic time series, statistical models often need to be supplemented with procedures that impose constraints while preserving smoothness over time. For example, GDP forecasts generated using models such as autoregressions or decision trees may not align with the long-term growth rates anticipated by forecasters. In such cases, forecasters aim to adjust the time series so that it converges smoothly to the desired long-term growth path. However, ad hoc constraint imposition, such as manually altering only the terminal value in a long time series, can introduce undesirable discontinuities between the penultimate and terminal values. Other such examples in economic forecasting can be found in @Ando2024Smooth and @AndoKim2023.

Systematically imposing constraints while retaining smoothness is important but challenging. Constraints often stem from accounting identities and expert judgment, making their incorporation essential for internal consistency. Smoothness is equally critical, as optimal forecasts typically exhibit less volatility than historical data, as in random walk. Achieving both objectives manually is resource-intensive, especially when dealing with numerous variables and constraints, raising the question of how to systematically impose constraints and smoothness.

Existing packages in R and Python assist forecast reconciliation and smoothing separately but not jointly. For instance, the `hts` [@Hyndmanetal2021] and `FoReco` [@GirolimettoDiFonzoPackage2023] packages in R support reconciliation, but the reconciled forecast may not be smooth over time. This is also the case for `hierarchicalforecast` [@Olivaresetal2024] package in Python. On the other hand, packages, such as `smooth` [@Svetnukov2024] and `forecast` [@Hyndmanetal2024] for R and `statsmodels` [@seabold2010statsmodels] for Python, provide methods to generate smooth forecasts but do not have the functionality to impose constraints.

To our knowledge, no package supports the simultaneous application of both reconciliation and smoothing, and this is the gap that `macroframe-forecast` attempts to fill. A more detailed explanation of `macroframe-forecast` can be found in @Andoetal2025.

<!---XXX[@AndoDasOrazbayev]XXX.--->

# Method

The framework consists of two steps, where the first step provides users with a flexible choice of forecasting models, and the second step allows users to adjust the first-step forecasts so that the forecasts are smooth over time and satisfy various constraints, such as accounting identities and pre-specified targets. For the theoretical properties, see @Ando2024Smooth.

Suppose there are $M$ time series to forecast, and if we stack the forecast horizon of all the time series, the size is $N$. The first-step forecast $\bar{y}\in \mathbb{R}^N$ can be generated using any model in the `sktime` [@Loningetal2019] python package. The second-step forecast $\tilde{y}$ is generated by solving the following quadratic programming problem

$$
\tilde{y} = \arg\min_{y \in \mathbb{R}^N} \; (y - \bar{y})^\top W^{-1} (y - \bar{y}) + y^\top \Phi y \quad \text{s.t.} \quad C_{\text{eq}} y - d_{\text{eq}} = 0, \quad C_{\text{ineq}} y - d_{\text{ineq}} \leq 0.
$$

The first term penalizes deviations from the first-step forecast $\bar{y}$, weighted by $W^{-1}$, where $W$ is an estimator of the first step forecast error covariance matrix. It ensures that accurate forecasts are adjusted less than less accurate ones. The second term enforces smoothness via $\Phi$, a block-diagonal matrix built from a degenerate penta-diagonal matrix used in the calculation of the Hodrick-Prescott filter [@HodrickPrescott1997]. $C_{\text{eq}} y - d_{\text{eq}} = 0$ refers to equality constraints, and $C_{\text{ineq}} y - d_{\text{ineq}} \leq 0$ refers to inequality constraints.


## Weight matrix selection
By default, $W$ is estimated using time series cross validation and Oracle Approximating Shrinkage (OAS) [@Chenetal2010], which shrinks the sample covariance toward a scalar. An alternative is OAS with diagonal target [@Ando2023High], which is robust when variables differ in scale. Users can also specify identity weighting or custom matrices.

## Smoothness parameters 

The smoothness matrix $\Phi$ is defined as 

$$
\Phi \;=\;
\begin{bmatrix}
\lambda_{1} F_{1} & & \\
& \ddots & \\
& & \lambda_{M} F_{M}
\end{bmatrix},
\quad
F_i \;=\;
\begin{bmatrix}
1   & -2  & 1   & 0      &        &        &        \\
-2  & 5   & -4  & 1      &        &        &        \\
1   & -4  & 6   & -4     &        &        &        \\
0   & 1   & -4  & 6      &        &       &        \\
    &     & \ddots & \ddots & \ddots & \ddots &     \\
    &     &    & 6       & -4      & 1     & 0      \\
    &     &    & -4     & 6      & -4     & 1      \\
    &     &     & 1      & -4     & 5      & -2     \\
    &     &     &  0      & 1      & -2     & 1
\end{bmatrix},
\quad
\lambda_i =   \frac{\lambda_i^*}{\sigma_i^2}$$

Where $i=1,...,M.$

Default parameter values $\lambda_i^*$ follow HP filter conventions (e.g., 1600 for quarterly data). It is then scaled by the first step forecast error variance $\sigma_i^2$, obtained from the diagonal elements of the weight matrix $W$ for each time series $i$, to ensure unit invariance. Setting $\lambda_i^* = 0$ disables smoothing for time series $i$, reducing the problem to pure reconciliation.


# An example: single-variable GDP forecast

Using U.S. nominal GDP data (1950-2024), we forecast the values for 2025-2030 under the constraint that 2030 growth rate equals 4 percent. When the column name of the variable to be forecasted is `GDP`, the constraint is expressed as `GDP_2030 - 1.04 * GDP_2029 = 0`. The `MFF` class generates the first-step forecast via the default pipeline and reconciles them to satisfy the constraint while smoothing the trajectory. Assuming that the user has read the GDP data as a `pandas` dataframe named `df0` with index `year` and `GDP`, the forecasts (both first and second-step) can be generated as follows:

```python
from macroframe_forecast import MFF
from macroframe_forecast.examples import generate_example_GDP_df

df0 = generate_example_GDP_df()
m = MFF(df0, equality_constraints=["GDP_2030 - 1.04 * GDP_2029"])
m.fit()
```

\begin{figure}[htbp]
\centering
\includegraphics[width=0.48\textwidth]{example_1_levels_figure.pdf}
\includegraphics[width=0.48\textwidth]{example_1_growth_figure.pdf}
\caption{US GDP forecasts: (a) levels and (b) growth.\label{fig:us_gdp}}
\end{figure}

Figure 1: Forecasts of U.S. nominal GDP, 2025-030, under the 4 percent growth constraint in 2030.  
*Source:* IMF April 2025 World Economic Outlook database and authors' calculations.  
*Note:* Panel (a) shows the forecast of annual US GDP in trillion USD. Panel (b) shows the growth rates computed from the level forecasts.


The second-step forecast can also be customized by providing exogenously defined first-step forecast, weight matrix, or the smoothness parameters. These can be achieved by using the function `Reconciliation` available in the package.

# Acknowledgements

We thank Mingmei Xiao, Yuki Sato, and Doga Bilgin for their earlier contributions.

# References
